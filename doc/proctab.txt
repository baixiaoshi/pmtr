proctab
=======
Troy D. Hanson <tdh@tkhanson.net>

Back to the https://github.com/troydhanson/proctab[proctab Github page].

To run services on Linux systems one typically writes an initscript. The init
mechanism, and the syntax of initscripts, vary depending on the distribution.

.proctab

Proctab is one of my http://troydhanson.github.io/[many C projects]. I wrote it
for sensors and appliances that have lots of related jobs that are easier to
manage through one configuration file. Also, to insulate the developer from
the underlying init system which varies widely.

I wrote 'proctab' to complement rather than replace the underlying init system.
It runs under systemd, sysvinit or upstart that already exists on a Linux host.
Its configuration file `/etc/proctab.conf` lists the services it should start.
It starts them at boot, and restarts them as needed.  Proctab is written in C,
Linux only, and is link:LICENSE.txt[MIT] licensed.

.Platforms

* Ubuntu (12, 13, 14, 15, 16)
* CentOS/RHEL (5, 6, 7)
* Raspberry Pi (Raspbian)
* Debian 
* Arch
* Yocto https://github.com/troydhanson/meta-proctab[(layer)]

Guide
-----

Download, build and install
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Build
^^^^^

To build it from the git repository, 

    git clone https://github.com/troydhanson/proctab.git
    cd proctab
    ./autogen.sh
    ./configure --bindir=/usr/bin --sysconfdir=/etc
    make

Install
^^^^^^^

To install the executable `/usr/bin/proctab` and the configuration file `/etc/proctab.conf`:

    sudo make install
    sudo touch /etc/proctab.conf

Initscript
^^^^^^^^^^

To have proctab installed a service, detecting the host init system automatically:

    cd initscripts
    sudo ./setup-initscript --install-service auto --bindir /usr/bin \
       --enable-service --start-service 

Note that `--bindir` should match the one given to "configure" in the build
step. You can also run `./setup-initscript -h` to see its full set of options.

proctab.conf
~~~~~~~~~~~~

The config file `/etc/proctab.conf` lists the processes for proctab to run. It
uses the term "job" to mean a service or a process.

.Example `/etc/proctab.conf`
--------------------------------------------------------
job {
  name set-audio-source
  cmd /usr/bin/Record_from_lineIn.sh
  wait
  once
}

job {
  name send-audio-to-icecast
  cmd /usr/bin/darkice -c /etc/darkice.cfg
  depends {
      /etc/darkice.cfg
  }
}

job {
  name tunnel
  cmd /usr/bin/ssh -i key -TNL 5901:127.0.0.1:5901 192.168.0.1
}

--------------------------------------------------------

Here we have a proctab configuration that runs three jobs. The
first one is a one-time, setup job that proctab won't restart. The
next two are a Darkice audio streamer and a persistent SSH tunnel.

There are many <<config_options,proctab configuration options>>.
The minimal requirement is that each job has a name and a cmd.

.depends

In the example above, darkice depends on `/etc/darkice.cfg`. This makes proctab 
restart darkice whenever darkice.cfg is edited. Proctab watches for these file
events efficiently using inotify. It restarts darkice if the content (thus, the
hash) of darkice.cfg changes. A simple open/close of darkice.cfg with no changes
will not restart the job. A job can depend on multiple files, listed one per
line.

.No shell

The commands are executed by fork and execv; there is no shell interpretation of
the command and its arguments. There is no PATH searching for the command. Use
absolute paths on commands.  The only quoting support is double-quotes in cmd
options such as

  cmd /bin/bash -c "killall Xvnc; vncserver :1"

This technique- launching a shell to execute a string- is handy.

.General rules

* Each job is in a curly-brace delimited block.  
* The order of options inside does not matter. 
* Only the `name` and `cmd` are required.
* Indentation is optional. 
* Blank lines are ok.  
* Comments start with `#` and must be on their own line.
* Processes that run under proctab should,
** stay in the foreground
** exit on SIGTERM or SIGKILL 
** clean up their own sub-processes


.Example job (lots of options)
---------------------------------------------------
# example of a process with lots of options
job {
  name generate-data
  dir /home/discovery
  cmd /usr/bin/perl gen.pl --remotes /tmp/a /tmp/b
  depends {
    /tmp/a
    /tmp/b
  }
  user daemon
  env PERLLIB=/home/discovery/lib
  ulimit -n infinity
  bounce every 1d
  out /var/log/gen.log
  err /var/log/gen.err
}

---------------------------------------------------

.Bounce every

Among the options shown in the job above is `bounce every 1d`.  This is useful
for scripts or other processes that might benefit from a periodic restart. It
takes other units, like `5m` for five minutes.

.ulimit

The job above can open infinite file descriptors (well, it can try) because
`ulimit -n infinite` allows it too. There are many limits (type `ulimit -a`
in the shell, or `help limit`) that can be explicitly set in this way.

.Environment variables

Environment variables can be set for a job by lines of the form `env VAR=value`.

.Standard output and error

As shown the stdout and stderr can be redirected to files. Otherwise they
are sent to `/dev/null`.

See the full list of <<config_options,proctab configuration options>>.

.Edits

When you edit and save `proctab.conf`, proctab applies the changes immediately.

 * A newly-added job gets started.
 * A deleted job is terminated.
 * A changed job is restarted with its new configuration.

Job termination
~~~~~~~~~~~~~~~

To terminate a job, proctab sends SIGTERM to it, then SIGKILL shortly afterward.
If a job terminates by itself (when proctab did not signal it to exit), and the
job does not have the `once` option, proctab restarts it. However, if the job
dies within 10 seconds of starting, proctab restarts it after waiting 10 seconds.
A job that dies immediately therefore undergoes a 10-second restart cycle (until
it stays running, if it ever does). This has two benefits: a job that is waiting
for some resource (say connection to a remote server) can die peacefully knowing
it will be restarted periodically, so it does not have to embed that logic itself.
Secondly, a process that is misconfigured (say, with a typo in its command string)
has little impact on the host because it only tries to restart every 10 seconds.

Status, control and logs
~~~~~~~~~~~~~~~~~~~~~~~~

To start, stop or get status of proctab, use the host system management commands.
Note that when you start proctab, it starts up all its jobs, just like at boot.
When you stop proctab, it signals all its jobs to terminate before it exits.  

.On a systemd-based host

  systemctl status proctab 
  systemctl start proctab 
  systemctl stop proctab 

.On many other systems

  service proctab status
  service proctab start
  service proctab stop

.Logs

Proctab logs to syslog, typically sent by the host system into the file
`/var/log/syslog` or `/var/log/messages`. Look there for messages about
proctab starting or restarting jobs, or errors in parsing `proctab.conf`.
You can also run `proctab -t` to check the syntax and report any errors. 

.systemd features

On systemd-based hosts, `systemctl status proctab` gives a nice view of the
proctab process hierarchy, as shown at the bottom of this command output.

----------------------------------------------------------------------------
% systemctl status proctab
● proctab.service - proctab process manager
   Loaded: loaded (/lib/systemd/system/proctab.service; enabled)
   Active: active (running) since Mon 2015-11-23 02:18:58 UTC; 12min ago
     Docs: http://troydhanson.github.io/proctab
 Main PID: 1463 (proctab)
   CGroup: /system.slice/proctab.service
           ├─1463 /usr/bin/proctab -F -c /etc/proctab.conf
           └─1556 /usr/bin/darkice -c /etc/darkice.cfg
           └─1557 /usr/bin/ssh -i key -TNL 5901:127.0.0.1:5901 192.168.0.1
----------------------------------------------------------------------------

Also, to view proctab logs on a systemd-based host, you can use:

    journalctl -u proctab

[[config_options]]
Appendix A: Configuration options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These options may appear in a job definition.

[[options]]
[width="90%",cols="20m,50",grid="none",options="header"]
|===============================================================================
|option         | argument
|name           | descriptive job name used for logging - must be unique
|cmd            | executable (fully-qualified) and any arguments 
|dir            | working directory (fully qualified) to run the process in
|out            | send stdout to this file
|err            | send stderr to this file
|in             | hook stdin to this file
|env            | environment variable setting `VAR=VALUE` (repeatable)
|user           | unix username under whose id to run the process 
|ulimit         | a flag and value, or a curly-brace delimited list of them
|bounce every   | a time interval like 5m (five minutes) - units are `smhd`
|depends        | a curly-brace delimited list of files, one per line
|disable        | this keyword disables the job 
|===============================================================================

More details on each option follows.

cmd
^^^
* The executable named in the `cmd` must have its executable-bit set. 
* The `cmd` may include trailing arguments e.g. `cmd /bin/node server.js`.  
* The `cmd` may contain double-quoted arguments e.g. `cmd /bin/echo "hello world"`
* The `cmd` does no shell expansion: no wildcards, backticks, variables, etc. 
* If you need shell features in your command, wrap it with a shell script. 
* You can wrap a shell script around something using this trick too:

  cmd /bin/bash -c "killall Xvnc; vncserver :1"

env
^^^
* Use `env` to push an environment variable into a job, e.g. `env TMPDIR=/tmp`.
* Use `env` repeatedly to set multiple environment variables.

disable
^^^^^^^
* Use `disable` to stop a job, without having to comment it out.
* This is often helpful in debugging a job since it makes it easy to 
  re-enable the job later (by commenting out the disable line, or removing it).

out, err, in
^^^^^^^^^^^^
* Use `out`, `err`, and `in` to attach stdout, stderr or stdin to a file.
* The stdout, stderr and stdin default to `/dev/null`.

user
^^^^
* The `user` option is the unix username that should be the process owner.
* The `user` defaults to root usually, when proctab is running as a service.
* The `user` defaults to whoever started proctab, if proctab was run manually.

depends
^^^^^^^
* Use a `depends` block to specify files, one per line, that the job depends on.
* If the content of any of the dependencies changes, proctab restarts the job.

bounce every
^^^^^^^^^^^^
* The `bounce every` option restarts the job every so often. 
* It's intended for jobs that don't behave well as long-running processes. 
* It takes a number and unit, like `5m` to restart a job every five minutes. 
* The units are `smhd`- (s)econds, (m)inutes, (h)ours or (d)ays. 
* The interval should be more than 10 seconds. 
* The exact timing of the restart is approximate.

ulimit
^^^^^^
* Use `ulimit` to modify the kernel-enforced resource limits for the job.
* It takes a flag denoting which limit to set, and a value, e.g., `ulimit -n 30`.  
* Alternatively, you can list a series of ulimit settings in a curly brace block:

  ulimit {
    -n infinity
    -l 10000
  }

* In bash, type `ulimit -a` in bash to list flags, and the values in your shell;
* In bash, type `help ulimit` for more information about the ulimits;
* In bash, type `man prlimit` to see the more technical description and the units.
* The values are all numeric or the keyword `infinity`.
* To see the current kernel limits on a process, run `cat /proc/<pid>/limits`.
* proctab sets both the "hard" and "soft" ulimit to the same value.
* If there is an error setting the ulimits, it's logged to syslog.

One-time jobs
^^^^^^^^^^^^^
Normally proctab runs permanent processes. However proctab supports one-time "setup"
jobs using the `wait` and `once` options.

  job {
    name setup-ramdisk
    cmd /bin/mkdir /dev/shm/ss
    wait
    once
  }

With `wait`, proctab waits for the job to exit before starting subsequent jobs. The
`once` option prevents proctab from restarting it. 

Appendix B: Proctab command-line options
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The host init system normally runs proctab at system boot. However you can run
proctab manually. These are the command line options that proctab accepts. 

.proctab options
[width="80%",cols="20m,50",grid="none",options="none"]
|==========================================================================
| -h        | show help    
| -F        | stay in foreground 
| -c <file> | specify configuration file
| -t        | test syntax (parse config file and exit)
| -v        | verbose logging (repeatable), -vv shows parsing
| -p <file> | make pidfile
|==========================================================================


Appendix C: Network reporting and control
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

NOTE: These features are disabled by default.

These configuration options may appear in `proctab.conf` at the global scope.

  report to udp://127.0.0.1:9999
  listen on udp://0.0.0.0:10000

The `report to` option designates a remote address and port to which proctab
should send a a UDP packet every ten seconds.  The packet payload lists the job
names, enabled or disabled status, and elapsed runtimes in simple text. If the
`report to` address falls in the multicast UDP range (e.g. 239.0.0.1, etc), the
specification may include a trailing interface, e.g., `report to
udp://239.0.0.1:9999@eth2` to designate the interface from which the multicast
UDP datagrams should egress. 

The `listen on` option allows jobs to be remotely enabled or disabled. It
specifies a UDP address and port that proctab should listen on for datagrams of
form `enable abc` or `disable abc`, where 'abc' is a job name.  The address
0.0.0.0 can be used as a shortcut to denote "any address" on this system.  The
effect is temporary; the settings in proctab.conf resume precedence when it's
edited or proctab is restarted.

These options are considered experimental and may be replaced or removed.

// vim: set tw=80 wm=2 syntax=asciidoc: 

