proctab
=======
Troy D. Hanson <tdh@tkhanson.net>

Back to the https://github.com/troydhanson/proctab[proctab Github page].

How do you run services at boot on Linux? How do you manage them afterward?
In a word, initscripts. The init mechanism varies from one Linux distro to
another- providing commands like 'service', 'chkconfig', and 'systemctl' that 
variously set up services to run in certain runlevels, start or stop them
or check their status. By 2016 'systemd' supplanted 'upstart' and traditional
'sysvinit' scripts - it's the best one yet, deeply integrated with Linux.
Ubuntu 15/16, RHEL7, Arch, Yocto, among others, use 'systemd'.

.proctab

I wrote 'proctab' to run as an umbrella service under the system init process.
It complements it, rather than replacing it. It has its own configuration file
where you can define any number of jobs. I wrote it for appliance or embedded
systems where a set of cooperating processes were most easily defined in a 
single configuration file. 

So to summarize, proctab:

* is a service that runs under the existing init system (systemd, upstart, etc)
* is an umbrella that runs the processes listed in its configuration file
* is an "abstraction layer" compatible with several init systems
* lets you list your application services under one proctab configuration
* complements the existing init system, running under it
* lets the existing OS init system run all the usual services 
* is my "hobby" where I hack process control features in to suit my needs :)

Rather than competing with 'systemd', 'upstart' and all the other init systems
out there, proctab is just my idiosyncratic take on process management for an
appliance made of many cooperating processes. Anything you can do under proctab,
could also be done directly as a system service; proctab is just a way to treat
a collection of processes as a single service under the parent init mechanism.

Proctab is written in C and targets Linux only. It runs on:

* Ubuntu (12, 13, 14, 15, 16)
* CentOS/RHEL (5, 6, 7)
* Debian 
* Arch
* Embedded systems- it has a Yocto layer
* Maker and embedded boards: Raspberry Pi, Intel Edison, etc

Proctab is free and open source. Here is the link:LICENSE.txt[license].

About

Proctab is a remix of pmtr that I wrote in 2011. I use it for several projects.
It's one of http://troydhanson.github.io/[a bunch of C projects] I keep.

Build & Install

To build it from the git repository, 

    git clone https://github.com/troydhanson/proctab.git
    cd proctab
    ./autogen.sh
    ./configure --prefix=/usr --sysconfdir=/etc
    make
    sudo make install

To set up the system service manager to run proctab, you can then do:

    cd system-service
    sudo ./setup-initscript --install-service --bindir /usr/bin
    sudo ./setup-initscript --start-service 

TODO:

* you can now edit /etc/proctab.conf
* yocto layer documentation  (yocto layer invokes configure and setup-initscript)

proctab
-------
The config file `/etc/proctab.conf` lists the processes (jobs) for proctab to run.  It
is meant to run permanent processes.  It restarts processes that exit.

.Example `/etc/proctab.conf`
--------------------------------------------------------

  job {
    name ssh-tunnel
    cmd /usr/bin/ssh -i key -TNL 5901:127.0.0.1:5901 box
  }

  job {
    name web-pub
    dir /opt
    cmd /usr/bin/kvsp-bpub -b cast -s -web tcp://0.0.0.0:9003
    err web.err
  }

--------------------------------------------------------

It takes lots of other options shown further below.

Build and Install
~~~~~~~~~~~~~~~~~

  git clone https://github.com/troydhanson/proctab.git
  cd proctab
  make
  sudo make install

Afterward proctab should already be running. Verify using `service proctab status` or
`systemd status proctab`.  The result of installation is:

 * the executable: `/usr/bin/proctab` 
 * the configuration file: `/etc/proctab.conf` 
 * an OS-specific initscript that runs proctab at boot 

Start/stop
~~~~~~~~~~

You can use the system's service command to start or stop proctab itself.

  service proctab start
  service proctab stop

Or on systemd-based systems,

  systemctl start proctab 
  systemctl status proctab 
  systemctl stop proctab 

Logs/Status
~~~~~~~~~~~
proctab logs to syslog. This is typically `/var/log/syslog` or `/var/log/messages`.

  Nov  7 1:38:10 ubuntu proctab[477]: started job proxy [478]

To get a nice visual confirmation of the jobs you have running under proctab, you
can use the `pstree` utility, if you have it installed.  Here is the output of
`pstree -p` truncated to show only proctab's process tree.

.Example pstree output
----------------------------------------
        ├─proctab(2830)─┬─proctab(2834)
        │               ├─proxy(2831)
        │               ├─sshd(2832)
        │               └─python(2833)
----------------------------------------

systemd-based systems
^^^^^^^^^^^^^^^^^^^^^
On systemd-based systems, `systemctl` gives a nice view of proctab and its sub-jobs:

----------------------------------------------------------------------------
systemctl status proctab
● proctab.service - proctab process manager
   Loaded: loaded (/lib/systemd/system/proctab.service; enabled)
   Active: active (running) since Mon 2015-11-23 02:18:58 UTC; 12min ago
     Docs: http://troydhanson.github.io/proctab
 Main PID: 1463 (proctab)
   CGroup: /system.slice/proctab.service
           ├─1463 /usr/bin/proctab -F -c /etc/proctab.conf
           ├─1470 /usr/bin/proctab -F -c /etc/proctab.conf
           └─1556 /bin/sleep 8
----------------------------------------------------------------------------

You can also view logs using:

    journalctl -u proctab

Jobs
~~~~
Processes that run under proctab should,

 * stay in the foreground
 * exit on SIGTERM or SIGKILL 
 * clean up their own sub-processes

The default proctab configuration file is `/etc/proctab.conf`. 

When you edit and save `proctab.conf`, it applies the changes immediately.

 * A newly-added job gets started.
 * A deleted job is terminated.
 * A changed job is restarted with its new configuration.

To terminate a job, proctab sends SIGTERM to it, then SIGKILL shortly afterward.

Config file
~~~~~~~~~~~
The configuration file contains any number of jobs. 

* Each job is in a curly-brace delimited block.  
* The order of options inside does not matter. 
* Only the `name` and `cmd` are required.
* Indentation is optional. 
* Blank lines are ok.  
* Comments start with `#` and must be on their own line.

.Example job
---------------------------------------------------
  job {
    name snmpmonitor
    cmd /usr/bin/snmp-mon -c snmp.conf
    user daemon
    depends {
      snmp.conf
      device.oid
    }
    env LD_LIBRARY_PATH=/opt/lib
    ulimit -n infinity
    bounce every 1d
  }
---------------------------------------------------

These options may appear in a job definition.

[[options]]
[width="90%",cols="20m,50",grid="none",options="header"]
|===============================================================================
|option         | argument
|name           | descriptive job name used for logging - must be unique
|cmd            | executable (fully-qualified) and any arguments 
|dir            | working directory (fully qualified) to run the process in
|out            | send stdout to this file
|err            | send stderr to this file
|in             | hook stdin to this file
|env            | environment variable setting `VAR=VALUE` (repeatable)
|user           | unix username under whose id to run the process 
|ulimit         | a flag and value, or a curly-brace delimited list of them
|bounce every   | a time interval like 5m (five minutes) - units are `smhd`
|depends        | a curly-brace delimited list of files, one per line
|disable        | this keyword disables the job 
|===============================================================================

More details on each option follows.

cmd
^^^
* The executable named in the `cmd` must have its executable-bit set. 
* The `cmd` may include trailing arguments e.g. `cmd /bin/node server.js`.  
* The `cmd` may contain double-quoted arguments e.g. `cmd /bin/echo "hello world"`
* The `cmd` does no shell expansion: no wildcards, backticks, variables, etc. 
* If you need shell features in your command, wrap it with a shell script. 
* You can wrap a shell script around something using this trick too:

  cmd /bin/bash -c "killall Xvnc; vncserver :1"

env
^^^
* Use `env` to push an environment variable into a job, e.g. `env TMPDIR=/tmp`.
* Use `env` repeatedly to set multiple environment variables.

disable
^^^^^^^
* Use `disable` to stop a job, without having to comment it out.
* This is often helpful in debugging a job since it makes it easy to 
  re-enable the job later (by commenting out the disable line, or removing it).

out, err, in
^^^^^^^^^^^^
* Use `out`, `err`, and `in` to attach stdout, stderr or stdin to a file.
* The stdout, stderr and stdin default to `/dev/null`.

user
^^^^
* The `user` option is the unix username that should be the process owner.
* The `user` defaults to root usually, when proctab is running as a service.
* The `user` defaults to whoever started proctab, if proctab was run manually.

depends
^^^^^^^
* Use a `depends` block to specify files, one per line, that the job depends on.
* If the content of any of the dependencies changes, proctab restarts the job.

bounce every
^^^^^^^^^^^^
* The `bounce every` option restarts the job every so often. 
* It's intended for jobs that don't behave well as long-running processes. 
* It takes a number and unit, like `5m` to restart a job every five minutes. 
* The units are `smhd`- (s)econds, (m)inutes, (h)ours or (d)ays. 
* The interval should be more than 10 seconds. 
* The exact timing of the restart is approximate.

ulimit
^^^^^^
* Use `ulimit` to modify the kernel-enforced resource limits for the job.
* It takes a flag denoting which limit to set, and a value, e.g., `ulimit -n 30`.  
* Alternatively, you can list a series of ulimit settings in a curly brace block:

  ulimit {
    -n infinity
    -l 10000
  }

* In bash, type `ulimit -a` in bash to list flags, and the values in your shell;
* In bash, type `help ulimit` for more information about the ulimits;
* In bash, type `man prlimit` to see the more technical description and the units.
* The values are all numeric or the keyword `infinity`.
* To see the current kernel limits on a process, run `cat /proc/<pid>/limits`.
* proctab sets both the "hard" and "soft" ulimit to the same value.
* If there is an error setting the ulimits, it's logged to syslog.

Restarts
^^^^^^^^
Since proctab is designed to keep things running, if a job exits, proctab restarts it.

* If a job exits quickly (within ten seconds of when it started) proctab 
  waits ten seconds then restarts it. This avoids rapid restart cycles. The
  job probably has some sort of configuration problem if it exits quickly.
* Exit status 33 can be returned from a process to tell proctab not to restart it.

One-time jobs
^^^^^^^^^^^^^
Normally proctab runs permanent processes. However proctab supports one-time "setup"
jobs using the `wait` and `once` options.

  job {
    name setup-ramdisk
    cmd /bin/mkdir /dev/shm/ss
    wait
    once
  }

With `wait`, proctab waits for the job to exit before starting subsequent jobs. The
`once` option prevents proctab from restarting it. 

proctab command line options
~~~~~~~~~~~~~~~~~~~~~~~~~

These are not normally used. The OS-specific initsystem (systemd, etc) normally runs
proctab at system boot. However you can run proctab manually. If you do, these are the 
command line options that proctab accepts. 

.proctab options
[width="80%",cols="20m,50",grid="none",options="none"]
|==========================================================================
| -h        | show help    
| -F        | stay in foreground 
| -c <file> | specify configuration file
| -t        | test syntax (parse config file and exit)
| -v        | verbose logging (repeatable), -vv shows parsing
| -p <file> | make pidfile
|==========================================================================


Experimental 
~~~~~~~~~~~~
These features are disabled by default.

These configuration options may appear in `proctab.conf` at the global scope.

  report to udp://127.0.0.1:9999
  listen on udp://0.0.0.0:10000

The `report to` option designates a remote address and port to which proctab should
send a a UDP packet every ten seconds.  The packet payload lists the job names,
enabled or disabled status, and elapsed runtimes in simple text. (An included
script `utils/proctab-rptserver` can receive these reports and write updates
to a text file summarizing the received status messages. This script is invoked
like `proctab-rptserver -p 9999 -f status.txt`).  If the `report to` address falls
in the multicast UDP range (e.g.  239.0.0.1, etc), the specification may include
a trailing interface, e.g., `report to udp://239.0.0.1:9999@eth2` to explicitly
designate the interface from which the multicast UDP datagrams should egress. 

The `listen on` option allows jobs to be remotely enabled or disabled. It
specifies a UDP address and port that proctab should listen on for datagrams of
form `enable abc` or `disable abc`, where 'abc' is a job name.  The address
0.0.0.0 can be used as a shortcut to denote "any address" on this system. (A
script in `utils/proctab-ctl` may be used to send the datagrams, for example 
`proctab-ctl -s 192.168.0.22 -p 10000 enable abc`). The effect is temporary; the
settings in proctab.conf resume precedence when it's edited or proctab is restarted.

// vim: set tw=80 wm=2 syntax=asciidoc: 

