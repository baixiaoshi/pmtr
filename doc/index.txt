pmtr: a Linux process supervisor
================================
Troy D. Hanson <tdh@tkhanson.net>

Back to the https://github.com/troydhanson/pmtr[pmtr Github page].

How do you run services at boot on Linux? Usually, the answer is initscripts.
(Or, for a hack, you can run them from /etc/rc.local). One of the more modern
and beautiful init systems is systemd. Ubuntu 15/16 and RHEL7 have adopted it.

Why on earth would I write my own manager for background services? Here's why:

I wanted 'one configuration file' for all the jobs that make up my appliance.

The one configuration file would ...

** react immediately to changes when edited
** abstract the OS-dependent init system away
** co-exist with the OS-dependent init system 
** be easily checked into git version control

Rather than competing with systemd, upstart and all the other init systems 
out there, pmtr is just my idiosyncratic take on process management for an
appliance made of many cooperating processes. Pmtr itself starts up using
the underlying init system (upstart, systemd, or traditional initscripts).

Pmtr is written in C and targets Linux only. It runs on:

* Ubuntu
* CentOS/RHEL
* Debian 
* Raspberry Pi (Raspbian) and Intel Edison (Yocto)
* probably others...

License
~~~~~~~
Pmtr is free and open source. Here is the link:LICENSE.txt[LICENSE].

About
~~~~~
I wrote pmtr in 2011. I've used it year in and year out on hundreds of systems.
If you have a favorite init system, you should use it. For me, pmtr does the
job, insulating me from the next great new init replacement. And really I like
being able to hack http://troydhanson.github.io/[my own stuff].

pmtr
----
The config file `/etc/pmtr.conf` lists the processes (jobs) for pmtr to run.  It
is meant to run permanent processes.  It restarts processes that exit.

.Example `/etc/pmtr.conf`
--------------------------------------------------------

  job {
    name ssh-tunnel
    cmd /usr/bin/ssh -i key -TNL 5901:127.0.0.1:5901 box
  }

  job {
    name snmp-mon 
    cmd /usr/bin/snmp-mon -c snmp.conf
    env LD_LIBRARY_PATH=/opt/lib
    ulimit -n infinity
    bounce every 1d
    user daemon
    depends {
      snmp.conf
      device.oid
    }
  }
--------------------------------------------------------

Build and Install
~~~~~~~~~~~~~~~~~

  git clone https://github.com/troydhanson/pmtr.git
  cd pmtr
  make
  sudo make install

Afterward pmtr should already be running. Verify using `service pmtr status` or
`systemd status pmtr`.  The result of installation is:

 * the executable: `/usr/bin/pmtr` 
 * the configuration file: `/etc/pmtr.conf` 
 * an OS-specific initscript that runs pmtr at boot 

Start/stop
~~~~~~~~~~

You can use the system's service command to start or stop pmtr itself.

  service pmtr start
  service pmtr stop

Or on systemd-based systems,

  systemctl start pmtr 
  systemctl status pmtr 
  systemctl stop pmtr 

When you stop pmtr, it stops the jobs that it's managing and then itself.
Pmtr logs to syslog. This is typically `/var/log/syslog` or `/var/log/messages`.

  Nov  7 1:38:10 ubuntu pmtr[477]: started job proxy [478]
  Nov  7 1:38:20 ubuntu pmtr[477]: job proxy [478] exited after 10 sec: exit status 0

Normally pmtr runs in the background. You can start it in the foreground using `-F`.

.pmtr options
[width="80%",cols="20m,50",grid="none",options="none"]
|==========================================================================
| -F        | stay in foreground 
| -c <file> | specify alternate configuration file
| -t        | test syntax (parse config file and exit)
| -v        | verbose logging (repeatable), -vv shows parsing
|==========================================================================

Jobs
~~~~
Processes that run under pmtr should,

 * stay in the foreground
 * exit on SIGTERM or SIGKILL 
 * clean up their own sub-processes

The default pmtr configuration file is `/etc/pmtr.conf`. 

When you edit and save `pmtr.conf`, it applies the changes immediately.

 * A newly-added job gets started.
 * A deleted job is terminated.
 * A changed job is restarted with its new configuration.

To terminate a job, pmtr sends SIGTERM to it, then SIGKILL shortly afterward.

Syntax 
^^^^^^
The configuration file contains any number of jobs. 

* Each job is in a curly-brace delimited block.  
* The order of options inside does not matter. 
* Only the `name` and `cmd` are required.
* Indentation is optional. 
* Blank lines are ok.  
* Comments start with `#` and must be on their own line.

.Example job
---------------------------------------------------
  job {
    name snmp-mon 
    cmd /usr/bin/snmp-mon -c snmp.conf
    env LD_LIBRARY_PATH=/opt/lib
    ulimit -n infinity
    bounce every 1d
    user daemon
    depends {
      snmp.conf
      device.oid
    }
  }
---------------------------------------------------

These options may appear in a job definition.

[[options]]
[width="90%",cols="20m,50",grid="none",options="header"]
|===============================================================================
|option         | argument
|name           | descriptive job name used for logging - must be unique
|cmd            | executable (fully-qualified) and any arguments 
|dir            | working directory (fully qualified) to run the process in
|out            | send stdout to this file
|err            | send stderr to this file
|in             | hook stdin to this file
|env            | environment variable setting `VAR=VALUE` (repeatable)
|user           | unix username under whose id to run the process 
|ulimit         | a flag and value, or a curly-brace delimited list of them
|bounce every   | a time interval like 5m (five minutes) - units are `smhd`
|depends        | a curly-brace delimited list of files, one per line
|disable        | this keyword disables the job 
|===============================================================================

More details on each option follows.

cmd
^^^
* The executable named in the `cmd` must have its executable-bit set. 
* The `cmd` may include trailing arguments e.g. `cmd /bin/node server.js`.  
* The `cmd` may contain double-quoted arguments e.g. `cmd /bin/echo "hello world"`
* The `cmd` does no shell expansion: no wildcards, backticks, variables, etc. 
* If you need shell features in your command, wrap it with a shell script. 
* You can wrap a shell script around something using this trick too:

  cmd /bin/bash -c "killall Xvnc; vncserver :1"

env
^^^
* Use `env` to push an environment variable into a job, e.g. `env TMPDIR=/tmp`.
* Use `env` repeatedly to set multiple environment variables.

disable
^^^^^^^
* Use `disable` to stop a job, without having to comment it out.
* This is often helpful in debugging a job since it makes it easy to 
  re-enable the job later (by commenting out the disable line, or removing it).

out, err, in
^^^^^^^^^^^^
* Use `out`, `err`, and `in` to attach stdout, stderr or stdin to a file.
* The stdout, stderr and stdin default to `/dev/null`.

user
^^^^
* The `user` option is the unix username that should be the process owner.
* The `user` defaults to root usually, when pmtr is running as a service.
* The `user` defaults to whoever started pmtr, if pmtr was run manually.

depends
^^^^^^^
* Use a `depends` block to specify files, one per line, that the job depends on.
* If the content of any of the dependencies changes, pmtr restarts the job.

bounce every
^^^^^^^^^^^^
* The `bounce every` option restarts the job every so often. 
* It's intended for jobs that don't behave well as long-running processes. 
* It takes a number and unit, like `5m` to restart a job every five minutes. 
* The units are `smhd`- (s)econds, (m)inutes, (h)ours or (d)ays. 
* The interval should be more than 10 seconds. 
* The exact timing of the restart is approximate.

ulimit
^^^^^^
* Use `ulimit` to modify the kernel-enforced resource limits for the job.
* It takes a flag denoting which limit to set, and a value, e.g., `ulimit -n 30`.  
* Alternatively, you can list a series of ulimit settings in a curly brace block:

  ulimit {
    -n infinity
    -l 10000
  }

* In bash, type `ulimit -a` in bash to list flags, and the values in your shell;
* In bash, type `help ulimit` for more information about the ulimits;
* In bash, type `man prlimit` to see the more technical description and the units.
* The values are all numeric or the keyword `infinity`.
* To see the current kernel limits on a process, run `cat /proc/<pid>/limits`.
* pmtr sets both the "hard" and "soft" ulimit to the same value.
* If there is an error setting the ulimits, it's logged to syslog.

Restarts
^^^^^^^^
Since pmtr is designed to keep things running, if a job exits, pmtr restarts it.

* If a job exits quickly (within ten seconds of when it started) pmtr 
  waits ten seconds then restarts it. This avoids rapid restart cycles. The
  job probably has some sort of configuration problem if it exits quickly.
* Exit status 33 can be returned from a process to tell pmtr not to restart it.

One-time jobs
^^^^^^^^^^^^^
Normally pmtr runs permanent processes. However pmtr supports one-time "setup"
jobs using the `wait` and `once` options.

  job {
    name setup-ramdisk
    cmd /bin/mkdir /dev/shm/ss
    wait
    once
  }

With `wait`, pmtr waits for the job to exit before starting subsequent jobs. The
`once` option prevents pmtr from restarting it. 

Experimental 
~~~~~~~~~~~~
These features are disabled by default.

These configuration options may appear in `pmtr.conf` at the global scope.

  report to udp://127.0.0.1:9999
  listen on udp://0.0.0.0:10000

The `report to` option designates a remote address and port to which pmtr should
send a a UDP packet every ten seconds.  The packet payload lists the job names,
enabled or disabled status, and elapsed runtimes in simple text. (An included
script `pmtr/utils/pmtr-rptserver` can receive these reports and write updates
to a text file summarizing the received status messages. This script is invoked
like `pmtr-rptserver -p 9999 -f status.txt`).  If the `report to` address falls
in the multicast UDP range (e.g.  239.0.0.1, etc), the specification may include
a trailing interface, e.g., `report to udp://239.0.0.1:9999@eth2` to explicitly
designate the interface from which the multicast UDP datagrams should egress. 

The `listen on` option allows jobs to be remotely enabled or disabled. It
specifies a UDP address and port that pmtr should listen on for datagrams of
form `enable abc` or `disable abc`, where 'abc' is a job name.  The address
0.0.0.0 can be used as a shortcut to denote "any address" on this system. (A
script in `pmtr/utils/pmtr-ctl` may be used to send the datagrams, for example 
`pmtr-ctl -s 192.168.0.22 -p 10000 enable abc`). The effect is temporary; the
settings in pmtr.conf resume precedence when it's edited or pmtr is restarted.

Tips
~~~~

pstree
^^^^^^
To get a nice visual confirmation of the jobs you have running under pmtr, you
can use the `pstree` utility, if you have it installed.  Here is the output of
`pstree -p`.

.Example pstree output
----------------------------------------
        ├─pmtr(2830)─┬─pmtr(2834)
        │            ├─proxy(2831)
        │            ├─sshd(2832)
        │            └─python(2833)
----------------------------------------

The other system processes have been omitted. Note that pmtr has its own child
process. This is the dependency monitor that watches the config file.

// vim: set tw=80 wm=2 syntax=asciidoc: 

